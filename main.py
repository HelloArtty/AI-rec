import json
import os
import random
from abc import ABC, abstractmethod

import numpy as np
import requests
import uvicorn
from dotenv import load_dotenv
from fastapi import FastAPI, HTTPException
from sentence_transformers import SentenceTransformer
from sklearn.cluster import KMeans

os.environ["TOKENIZERS_PARALLELISM"] = "false"
load_dotenv()
    
class MealPlanner(ABC):
    def __init__(self):
        self.url = os.getenv("URL")

    def get_data(self):
        """‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏à‡∏≤‡∏Å API"""
        url = self.url + "get_limit"
        
        try:
            response = requests.get(url)
            response.raise_for_status()
            data = response.json()
            print("üì• ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ñ‡∏π‡∏Å‡∏î‡∏∂‡∏á‡∏°‡∏≤‡πÄ‡∏£‡∏µ‡∏¢‡∏ö‡∏£‡πâ‡∏≠‡∏¢‡πÅ‡∏•‡πâ‡∏ß!")
            # print(json.dumps(data, indent=4))
            if not isinstance(data, dict):
                raise ValueError("Invalid data format from API")
            return data
        except requests.exceptions.RequestException as err:
            print(f"‚ùå Error fetching data: {err}")
            return None
        except (json.JSONDecodeError, ValueError) as err:
            print(f"‚ùå Error processing data: {err}")
            return None

    @staticmethod
    def calculate_total_nutrition(meals):
        """‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏™‡∏≤‡∏£‡∏≠‡∏≤‡∏´‡∏≤‡∏£‡∏£‡∏ß‡∏°"""
        valid_meals = [meal for meal in meals if isinstance(meal, dict) and "nutrition" in meal]
        if not valid_meals:
            return {}
        
        total_nutrition = {key: 0 for key in valid_meals[0]["nutrition"].keys()}
        for meal in valid_meals:
            for key, value in meal["nutrition"].items():
                total_nutrition[key] += value
        return total_nutrition

    @staticmethod
    def is_within_nutrition_limit(meals, nutrition_limit):
        """‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏Ç‡∏≠‡∏ö‡πÄ‡∏Ç‡∏ï‡πÇ‡∏†‡∏ä‡∏ô‡∏≤‡∏Å‡∏≤‡∏£"""
        total_nutrition = MealPlanner.calculate_total_nutrition(meals)
        return all(total_nutrition.get(key, 0) <= nutrition_limit.get(key, float('inf')) 
                for key in nutrition_limit)

    @abstractmethod
    def process_mealplan(self, *args, **kwargs):
        """Abstract method to be implemented by child classes"""
        pass

    @abstractmethod
    def send_mealplan(self, mealplan):
        """ ‡∏™‡πà‡∏á‡πÅ‡∏ú‡∏ô‡∏°‡∏∑‡πâ‡∏≠‡∏≠‡∏≤‡∏´‡∏≤‡∏£‡πÑ‡∏õ‡∏¢‡∏±‡∏á‡πÄ‡∏ã‡∏¥‡∏£‡πå‡∏ü‡πÄ‡∏ß‡∏≠‡∏£‡πå """
        url = os.getenv("URL") + "mealplan"
        try:
            response = requests.post(url, json=mealplan)
            response.raise_for_status()
            print("‚úÖ ‡πÅ‡∏ú‡∏ô‡∏°‡∏∑‡πâ‡∏≠‡∏≠‡∏≤‡∏´‡∏≤‡∏£‡∏ñ‡∏π‡∏Å‡∏™‡πà‡∏á‡πÑ‡∏õ‡∏¢‡∏±‡∏á‡πÄ‡∏ã‡∏¥‡∏£‡πå‡∏ü‡πÄ‡∏ß‡∏≠‡∏£‡πå‡πÄ‡∏£‡∏µ‡∏¢‡∏ö‡∏£‡πâ‡∏≠‡∏¢‡πÅ‡∏•‡πâ‡∏ß!")
        except requests.exceptions.RequestException as err:
            print(f"‚ùå Error sending meal plan: {err}")

class CreateMealPlan(MealPlanner):
    def __init__(self):
        super().__init__()
        

    def find_optimal_clusters(self, food_menus):
        """‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏Ñ‡∏•‡∏±‡∏™‡πÄ‡∏ï‡∏≠‡∏£‡πå‡∏ó‡∏µ‡πà‡πÄ‡∏´‡∏°‡∏≤‡∏∞‡∏™‡∏°"""
        model = SentenceTransformer('all-MiniLM-L6-v2')
        meal_names = [meal['name'] for meal in food_menus]
        embeddings = model.encode(meal_names)
        
        unique_embeddings = np.unique(embeddings, axis=0)
        max_clusters = min(10, len(unique_embeddings))
        
        distortions = []
        K = range(1, max_clusters + 1)
        for k in K:
            kmeans = KMeans(n_clusters=k, random_state=42, n_init=10).fit(embeddings)
            distortions.append(kmeans.inertia_)
        
        if not distortions:
            raise ValueError("No distortions calculated, check the input data.")
        
        optimal_clusters = np.argmin(np.diff(distortions)) + 2 if len(distortions) > 1 else 1
        return optimal_clusters

    def cluster_meals(self, food_menus):
        """‡∏à‡∏±‡∏î‡∏Å‡∏•‡∏∏‡πà‡∏°‡∏≠‡∏≤‡∏´‡∏≤‡∏£"""
        num_clusters = self.find_optimal_clusters(food_menus)
        model = SentenceTransformer('all-MiniLM-L6-v2')
        meal_names = [meal['name'] for meal in food_menus]
        embeddings = model.encode(meal_names)
        
        kmeans = KMeans(n_clusters=num_clusters, random_state=42, n_init=10)
        clusters = kmeans.fit_predict(embeddings)
        
        clustered_meals = {i: [] for i in range(num_clusters)}
        for meal, cluster in zip(food_menus, clusters):
            clustered_meals[cluster].append(meal)
        
        return clustered_meals

    def process_mealplan(self, food_data):
        """‡∏™‡∏£‡πâ‡∏≤‡∏á‡πÅ‡∏ú‡∏ô‡∏°‡∏∑‡πâ‡∏≠‡∏≠‡∏≤‡∏´‡∏≤‡∏£"""
        if not isinstance(food_data, dict) or "food_menus" not in food_data:
            raise ValueError("Invalid food_data format")
        
        food_menus = food_data["food_menus"]
        user_id = food_data.get("user_id")
        days = food_data.get("days")
        # days = 1
        nutrition_limit = food_data.get("nutrition_limit_per_day", {})
        
        clustered_meals = self.cluster_meals(food_menus)
        
        mealplan = {
            "user_id": user_id,
            "mealplans": [],
            # "total_nutrition_per_day": []
        }
        selected_meals = set()
        
        for _ in range(days):
            daily_meals = []
            for cluster in clustered_meals.values():
                random.shuffle(cluster)
                for meal in cluster:
                    if len(daily_meals) >= 3:
                        break
                    if (meal["name"] not in selected_meals and
                        self.is_within_nutrition_limit(daily_meals + [meal], nutrition_limit)):
                        daily_meals.append(meal)
                        selected_meals.add(meal["name"])
                if len(daily_meals) >= 3:
                    break
            
            # total_nutrition = self.calculate_total_nutrition(daily_meals)
            mealplan["mealplans"].append(daily_meals if daily_meals else [])
            # mealplan["total_nutrition_per_day"].append(total_nutrition)

        return mealplan

    def send_mealplan(self, mealplan):
        """‡∏™‡πà‡∏á‡πÅ‡∏ú‡∏ô‡∏°‡∏∑‡πâ‡∏≠‡∏≠‡∏≤‡∏´‡∏≤‡∏£‡πÑ‡∏õ‡∏¢‡∏±‡∏á‡πÄ‡∏ã‡∏¥‡∏£‡πå‡∏ü‡πÄ‡∏ß‡∏≠‡∏£‡πå"""
        url = self.url + "mealplan"
        try:
            response = requests.post(url, json=mealplan)
            response.raise_for_status()
            print("‚úÖ ‡πÅ‡∏ú‡∏ô‡∏°‡∏∑‡πâ‡∏≠‡∏≠‡∏≤‡∏´‡∏≤‡∏£‡∏ñ‡∏π‡∏Å‡∏™‡πà‡∏á‡πÑ‡∏õ‡∏¢‡∏±‡∏á‡πÄ‡∏ã‡∏¥‡∏£‡πå‡∏ü‡πÄ‡∏ß‡∏≠‡∏£‡πå‡πÄ‡∏£‡∏µ‡∏¢‡∏ö‡∏£‡πâ‡∏≠‡∏¢‡πÅ‡∏•‡πâ‡∏ß!")
        except requests.exceptions.RequestException as err:
            print(f"‚ùå Error sending meal plan: {err}")
            raise HTTPException(status_code=500, detail=str(err))

class UpdateMealPlan:
    def __init__(self):
        self.url = os.getenv("URL")
    
    def get_data(self):
        """ ‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏à‡∏≤‡∏Å API """
        url = self.url + "get_limit"
        try:
            response = requests.get(url)
            response.raise_for_status()
            data = response.json()
            
            if "food_menus" not in data or "nutrition_limit_per_day" not in data:
                print(f"‚ùå Invalid data format: {data}")
                return None
            
            return data
        except requests.exceptions.RequestException as err:
            print(f"‚ùå Error fetching data: {err}")
            return None
    
    def get_mealplan(self):
        """ ‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÅ‡∏ú‡∏ô‡∏°‡∏∑‡πâ‡∏≠‡∏≠‡∏≤‡∏´‡∏≤‡∏£‡∏à‡∏≤‡∏Å API """
        url = self.url + "get_mealplan"
        try:
            response = requests.get(url)
            response.raise_for_status()
            data = response.json()
            
            if "mealplans" not in data:
                print(f"‚ùå Key 'mealplans' not found in response: {data}")
                data["mealplans"] = []
            
            return data
        except requests.exceptions.RequestException as err:
            print(f"‚ùå Error fetching meal plan: {err}")
            return None
    
    def send_mealplan(self, mealplan):
        """ ‡∏™‡πà‡∏á‡πÅ‡∏ú‡∏ô‡∏°‡∏∑‡πâ‡∏≠‡∏≠‡∏≤‡∏´‡∏≤‡∏£‡πÑ‡∏õ‡∏¢‡∏±‡∏á‡πÄ‡∏ã‡∏¥‡∏£‡πå‡∏ü‡πÄ‡∏ß‡∏≠‡∏£‡πå """
        url = f"{self.url}update_mealplan"
        try:
            response = requests.post(url, json=mealplan)
            response.raise_for_status()
            print("‚úÖ ‡πÅ‡∏ú‡∏ô‡∏°‡∏∑‡πâ‡∏≠‡∏≠‡∏≤‡∏´‡∏≤‡∏£‡∏ñ‡∏π‡∏Å‡∏™‡πà‡∏á‡πÑ‡∏õ‡∏¢‡∏±‡∏á‡πÄ‡∏ã‡∏¥‡∏£‡πå‡∏ü‡πÄ‡∏ß‡∏≠‡∏£‡πå‡πÄ‡∏£‡∏µ‡∏¢‡∏ö‡∏£‡πâ‡∏≠‡∏¢‡πÅ‡∏•‡πâ‡∏ß!")
        except requests.exceptions.RequestException as err:
            print(f"‚ùå Error sending meal plan: {err}")
    
    def calculate_total_nutrition(self, meals):
        """ ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏™‡∏≤‡∏£‡∏≠‡∏≤‡∏´‡∏≤‡∏£‡∏£‡∏ß‡∏°‡∏à‡∏≤‡∏Å‡∏°‡∏∑‡πâ‡∏≠‡∏≠‡∏≤‡∏´‡∏≤‡∏£‡∏ó‡∏µ‡πà‡πÑ‡∏°‡πà‡πÄ‡∏õ‡πá‡∏ô {} """
        valid_meals = [meal for meal in meals if isinstance(meal, dict) and "nutrition" in meal]
        if not valid_meals:
            return {}
        
        total_nutrition = {key: 0 for key in valid_meals[0]["nutrition"].keys()}
        
        for meal in valid_meals:
            for key, value in meal["nutrition"].items():
                total_nutrition[key] += value
        
        return total_nutrition
    
    def is_within_nutrition_limit(self, meals, nutrition_limit):
        total_nutrition = self.calculate_total_nutrition(meals)
        return all(total_nutrition.get(key, 0) <= nutrition_limit.get(key, float('inf')) for key in nutrition_limit)
    
    def update_mealplan(self, mealplan, food_menus, nutrition_limit):
        total_nutrition_per_day = []

        for daily_meals in mealplan["mealplans"]:
            used_recipes = {meal["recipe_id"] for meal in daily_meals if isinstance(meal, dict) and "recipe_id" in meal}

            for i in range(len(daily_meals)):
                if daily_meals[i] == {}:  # ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡∏°‡∏∑‡πâ‡∏≠‡∏≠‡∏≤‡∏´‡∏≤‡∏£‡πÄ‡∏õ‡πá‡∏ô‡∏Ñ‡πà‡∏≤‡∏ß‡πà‡∏≤‡∏á‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà
                    available_meals = [meal for meal in food_menus if meal["recipe_id"] not in used_recipes]
                    random.shuffle(available_meals)  # ‡∏™‡∏∏‡πà‡∏°‡∏•‡∏≥‡∏î‡∏±‡∏ö‡πÄ‡∏°‡∏ô‡∏π‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡∏´‡∏•‡∏≤‡∏Å‡∏´‡∏•‡∏≤‡∏¢

                    for meal in available_meals:
                        if self.is_within_nutrition_limit(daily_meals + [meal], nutrition_limit):
                            daily_meals[i] = meal
                            used_recipes.add(meal["recipe_id"])  # ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡πÄ‡∏°‡∏ô‡∏π‡∏ó‡∏µ‡πà‡πÉ‡∏ä‡πâ‡πÑ‡∏õ‡πÅ‡∏•‡πâ‡∏ß
                            break
            
            # ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏™‡∏≤‡∏£‡∏≠‡∏≤‡∏´‡∏≤‡∏£‡∏£‡∏ß‡∏°‡∏Ç‡∏≠‡∏á‡∏ß‡∏±‡∏ô‡∏ô‡∏±‡πâ‡∏ô ‡πÜ
            total_nutrition_per_day.append(self.calculate_total_nutrition(daily_meals))

        # ‡πÄ‡∏û‡∏¥‡πà‡∏° total_nutrition_per_day ‡∏•‡∏á‡πÉ‡∏ô JSON
        # mealplan["total_nutrition_per_day"] = total_nutrition_per_day
        return mealplan

app = FastAPI()

@app.get("/")
async def root():
    return {"message": "API is running!"}
    
@app.get("/ai")
async def create_meals():
    print("üçΩ ‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏à‡∏≤‡∏Å‡πÄ‡∏ã‡∏¥‡∏£‡πå‡∏ü‡πÄ‡∏ß‡∏≠‡∏£‡πå...")

    creator = CreateMealPlan()
    food_data = creator.get_data()
    if not food_data:
        raise HTTPException(status_code=500, detail="Error fetching data")

    print("üîç ‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏™‡∏£‡πâ‡∏≤‡∏á‡πÅ‡∏ú‡∏ô‡∏°‡∏∑‡πâ‡∏≠‡∏≠‡∏≤‡∏´‡∏≤‡∏£...")
    try:
        mealplan = creator.process_mealplan(food_data)
        creator.send_mealplan(mealplan)
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))
    
    # return {"message": "‡πÅ‡∏ú‡∏ô‡∏°‡∏∑‡πâ‡∏≠‡∏≠‡∏≤‡∏´‡∏≤‡∏£‡∏ñ‡∏π‡∏Å‡∏™‡∏£‡πâ‡∏≤‡∏á‡πÄ‡∏£‡∏µ‡∏¢‡∏ö‡∏£‡πâ‡∏≠‡∏¢‡πÅ‡∏•‡πâ‡∏ß!"}
    return mealplan

@app.get("/ai_update")
async def update_meals():
    updater = UpdateMealPlan()
    print("üçΩ ‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏à‡∏≤‡∏Å‡πÄ‡∏ã‡∏¥‡∏£‡πå‡∏ü‡πÄ‡∏ß‡∏≠‡∏£‡πå...")

    try:
        food_data = updater.get_data()
        if not food_data:
            raise HTTPException(status_code=500, detail="‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÑ‡∏î‡πâ")
        
        print("üîç ‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏™‡∏£‡πâ‡∏≤‡∏á‡πÅ‡∏ú‡∏ô‡∏°‡∏∑‡πâ‡∏≠‡∏≠‡∏≤‡∏´‡∏≤‡∏£...")
        mealplan = updater.get_mealplan()
        if not mealplan:
            raise HTTPException(status_code=500, detail="‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏î‡∏∂‡∏á‡πÅ‡∏ú‡∏ô‡∏°‡∏∑‡πâ‡∏≠‡∏≠‡∏≤‡∏´‡∏≤‡∏£‡πÑ‡∏î‡πâ")
        
        updated_mealplan = updater.update_mealplan(mealplan, food_data["food_menus"], food_data["nutrition_limit_per_day"])
        updater.send_mealplan(updated_mealplan)
    
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

    # return {"message": "‡πÅ‡∏ú‡∏ô‡∏°‡∏∑‡πâ‡∏≠‡∏≠‡∏≤‡∏´‡∏≤‡∏£‡∏ñ‡∏π‡∏Å‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡πÄ‡∏£‡∏µ‡∏¢‡∏ö‡∏£‡πâ‡∏≠‡∏¢‡πÅ‡∏•‡πâ‡∏ß!"}
    return updated_mealplan


if __name__ == "__main__":
    uvicorn.run(app, host="0.0.0.0", port=int(os.environ.get("PORT", 4000)))